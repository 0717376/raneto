---
Title: Операторы JOIN. Типы объединения таблиц
Sort: 6
---

Вспомните, как в уроке про связи мы делили таблицу с заказами на несколько. Обычному пользователю работать с такой структурой сложно. Придётся искать нужную информацию в нескольких таблицах и сравнивать совпадающие идентификаторы. 

Таблицы можно объединять и таким образом возвращать их к первоначальному неоптимальному виду — частично или полностью.

Допустим, вы получили такую задачу: выгрузить таблицу с данными пользователей, совершивших конкретные заказы.

#### Таблица с заказами

Номер заказа|	Идентификатор покупателя|	Идентификатор товара|	Количество
--|--|--|--
1|	1|	1|	1
2|	1|	2|	1
3|	1|	3|	4
4|	1|	4|	2
5|	2|	5|	1
6|	2|	4|	4
<br>

#### Таблица с покупателями

Идентификатор покупателя|	Фамилия|	Имя|	Отчество|	Адрес|	Телефон
--|--|--|--|--|--
1|	Иванов|	Николай|	Петрович|	г. Москва, Ленинский переулок, дом 3, кв. 26|	654-42-18
2|	Куравкова|	Татьяна|	Алексеевна|	г. Рязань, ул. Юбилейная, дом 18, кв. 61|	805-66-88
<br>

Попробуем сформулировать, пока не на языке SQL, как можно решить такую задачу. Сначала выгрузим таблицу с заказами и к ней присоединим данные о покупателях. Для этого понадобится идентификатор покупателя. Когда идентификатор из таблицы с заказами совпадёт с числом из таблицы с клиентами, нужно добавить к заказу данные покупателя.

Проследим по строкам, как такую задачу выполнит программа:
1. Возьмём первую запись таблицы с заказами. В поле с идентификатором покупателя указано число 1. Перейдём в таблицу с покупателями и увидим, что этому числу соответствует Николай Иванов. Значит, в первую запись добавятся его данные.
1. В следующих трёх записях с заказами указан тот же идентификатор. Программа снова добавит данные Николая Иванова.
1. В пятой и шестой записях уже другой идентификатор — 2. Он соответствует Татьяне Куравковой. Добавим её данные к заказу.

Когда программа выполнит все шаги, получится такая итоговая таблица:

Номер заказа|	Идентификатор покупателя|	Идентификатор товара|	Количество|	Фамилия|	Имя|	Отчество|	Адрес|	Телефон
--|--|--|--|--|--|--|--|--
1|	1|	1|	1|	Иванов|	Николай|	Петрович|	г. Москва, Ленинский переулок, дом 3, кв. 26|	654-42-18
2|	1|	2|	1|	Иванов|	Николай|	Петрович|	г. Москва, Ленинский переулок, дом 3, кв. 26|	654-42-18
3|	1|	3|	4|	Иванов|	Николай|	Петрович|	г. Москва, Ленинский переулок, дом 3, кв. 26|	654-42-18
4|	1|	4|	2|	Иванов|	Николай|	Петрович|	г. Москва, Ленинский переулок, дом 3, кв. 26|	654-42-18
5|	2|	5|	1|	Куравкова|	Татьяна|	Алексеевна|	г. Рязань, ул. Юбилейная, дом 18, кв. 61|	805-66-88
6|	2|	4|	4|	Куравкова|	Татьяна|	Алексеевна|	г. Рязань, ул. Юбилейная, дом 18, кв. 61|	805-66-88
<br>

Давайте повторим, зачем нужно разделять таблицы и затем соединять их заново. Сегментация данных упрощает поиск и изменение данных. Не стоит забывать и о том, что объёмная таблица занимает больше места.

Объединяя данные, специалисты получают более информативные таблицы. Содержанием этих таблиц можно управлять, например, если выгружать конкретные столбцы или фильтровать данные. 

### Операторы JOIN

Переходим к самому интересному — объединению таблиц в запросе. Расскажем на примере уже знакомой базы данных интернет-магазина. 
В PostgreSQL для соединения таблиц используют операторы JOIN. Каждый из них объединяет таблицы по-разному. В этом уроке вы узнаете, что стоит за каждым типом объединения, а применять операторы потренируетесь в следующих уроках.

### Тип INNER JOIN

Тип INNER JOIN предполагает объединение по «внутренней» области, общей для двух таблиц. Покажем на примере таблиц с фамилиями покупателей и числом покупок. Объединить две таблицы можно с помощью общего поля ID_покупателя. Если использовать оператор INNER JOIN, таблица сложится из совпадающих значений в поле ID_покупателя в обеих таблицах.

<img src="%base_url%/images/1_border2880_1627651612.png"/>
<br><br>

Значение `ID_покупателя`, равное 667, присутствует в обеих таблицах. Поэтому фамилия из первой таблицы объединяется с числом покупок из второй.

<img src="%base_url%/images/2_border2880_1627651642.png"/>
<br><br>

То же самое происходит с другими покупателями, если значение в поле `ID_покупателя` встречается в обеих таблицах. Но не все покупатели вошли в финальную таблицу — в том случае, если идентификаторы не совпали.

### Тип LEFT OUTER JOIN

LEFT OUTER JOIN — тип объединения, который предполагает, что в результат слияния войдут все записи из левой таблицы. Записи из правой таблицы сохранятся только в том случае, если значения в нужном поле совпадают со значениями в левой таблице.

<img src="%base_url%/images/3_border2880_1627651666.png"/>
<br><br>

Таблица слева содержит информацию о фамилиях покупателей, поэтому все эти данные вошли в финальную таблицу. Для некоторых фамилий не нашлось совпадений в правой таблице, поэтому в поле `Число покупок` будет значение `NULL`. Данные о покупателях с идентификаторами 111, 221 и 456 в результат слияния не войдут, ведь таких значений нет в левой таблице. 

### Тип RIGHT OUTER JOIN

Тип `RIGHT OUTER JOIN` похож на предыдущий тип объединения, только в этом случае больший приоритет у правой таблицы. Оператор `RIGHT OUTER JOIN` предполагает, что записи из правой таблицы обязательно войдут в результат слияния. А записи из левой таблицы сохранятся только в том случае, если значения в нужном поле совпадают со значениями в правой таблице. На месте некоторых фамилий указано значение `NULL` — в том случае, если нужных данных в левой таблице нет.

<img src="%base_url%/images/4_border2880_1627651693.png"/>
<br><br>

### Тип FULL OUTER JOIN

Оператор FULL OUTER JOIN объединяет все данные из левой и правой таблиц. Если не нашлось совпадения, на месте значения будет NULL.

<img src="%base_url%/images/5_border2880_1627651723.png"/>
<br><br>

